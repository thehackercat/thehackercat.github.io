<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Django-rest-framework | TheHackerCat's Blog]]></title>
  <link href="http://thehackercat.me/blog/categories/django-rest-framework/atom.xml" rel="self"/>
  <link href="http://thehackercat.me/"/>
  <updated>2016-04-08T14:57:59+08:00</updated>
  <id>http://thehackercat.me/</id>
  <author>
    <name><![CDATA[TheHackerCat]]></name>
    <email><![CDATA[lexuscyborg103@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DRF 教程4 - 验证与授权]]></title>
    <link href="http://thehackercat.me/blog/2016/04/07/drf-tutorial4/"/>
    <updated>2016-04-07T09:52:33+08:00</updated>
    <id>http://thehackercat.me/blog/2016/04/07/drf-tutorial4</id>
    <content type="html"><![CDATA[<h2>验证与授权</h2>

<p>目前来看，我们的 API 并没有权限上的限制(即任何人都可以编辑或删除我们的 Movies )，这不是我们想要的。所以我们需要在 API 上做些限制以确保:</p>

<ul>
<li>Movies 与 Users 关联起来。</li>
<li>只有授权了的用户才能创建新的 Movies。</li>
<li>只有 Movies 的创建者才可以更新或删除它。</li>
<li>未授权的用户只能进行查看。</li>
</ul>


<!--more-->


<h3>在 models 中增加以下信息</h3>

<p>我们先把之前注释掉的</p>

<pre><code class="python">director = models.ForeignKey('celebrity', related_name='Movies')

class celebrity(models.Model):
    name = models.CharField(max_length=100, blank=True, default='')
    age = models.IntegerField()
    gender = models.CharField(choices=GENDER_CHOICES, default='male', max_length=20)
</code></pre>

<p>关联导演类的注释解开，来看看多张表在生成的 api 里的关联性。</p>

<p>接着在 <code>models.py</code> 中的 Movies 类中加入以下代码来确定 Movies 的创建者:</p>

<pre><code class="python">owner = models.ForeignKey('auth.User', related_name='Movies')
</code></pre>

<p>最后 <code>models.py</code> 代码为:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from django.db import models

# 举个栗子
COUNTRY_CHOICES = (
    ('US', 'US'),
    ('Asia', 'Asia'),
    ('CN', 'CN'),
    ('TW', 'TW'),
)
TYPE_CHOICES = (
    ('Drama', 'Drama'),
    ('Thriller', 'Thriller'),
    ('Sci-Fi', 'Sci-Fi'),
    ('Romance', 'Romance'),
    ('Comedy', 'Comedy')
)
GENDER_CHOICES = (
    ('male', 'male'),
    ('female', 'female')
)

class Movies(models.Model):
    title = models.CharField(max_length=100, blank=True, default='')
    year = models.CharField(max_length=20)
    # 在 director 关联了 Movies 类 和 celecrity 类, 在第4章会用到 celebrity 类
    director = models.ForeignKey('celebrity', related_name='movies')
    # 关联 User 类来确定 Movies 的创建者
    owner = models.ForeignKey('auth.User', related_name='movies')
    country = models.CharField(choices=COUNTRY_CHOICES, default='US', max_length=20)
    type = models.CharField(choices=TYPE_CHOICES, default='Romance', max_length=20)
    rating = models.DecimalField(max_digits=3, decimal_places=1)
    created = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('created',)

class celebrity(models.Model):
    name = models.CharField(max_length=100, blank=True, default='')
    age = models.IntegerField()
    gender = models.CharField(choices=GENDER_CHOICES, default='male', max_length=20)
</code></pre>

<p>修改完了模型，我们需要更新一下数据表。</p>

<p>通常来讲，我们会创建一个数据库 migration 来更新数据表，但是为了图省事儿，宝宝我索性删了整张 Movies 表直接重建！</p>

<p>在数据库中删除 douban_movies 表后在终端中执行以下命令:</p>

<pre><code class="bash">$ python manage.py syncdb
</code></pre>

<p>接着我们可能会需要多个 User 来测试 API ，如果之前你没有创建 Django Super User 的话，用以下命令创建:</p>

<pre><code class="bash">$ python manage.py createsuperuser
</code></pre>

<p>然后进入 <code>http://127.0.0.1/admin/</code> 界面，登录并找到  <code>/user/</code> 表，然后在里面手动创建 user 并赋予权限。</p>

<h3>为新增的模型增加 endpoints</h3>

<p>既然现在我们已经有了 users 模型和 celebrity 模型，那么现在需要做的就是在 <code>serializer.py</code> 中让他们在 API 中展现出来，加入以下代码:</p>

<pre><code class="python">class UserSerializer(serializers.ModelSerializer):
    movies = serializers.PrimaryKeyRelatedField(many=True, queryset=Movies.objects.all())

    class Meta:
        model = User
        fields = ('id', 'username', 'movies')

class DirectorSerializer(serializers.ModelSerializer):
    movies = serializers.PrimaryKeyRelatedField(many=True, queryset=Movies.objects.all())

    class Meta:
        model = celebrity
        fields = ('id', 'name', 'age', 'gender', 'movies')
</code></pre>

<p>因为我们之前在 <code>models.py</code> 中添加了 <code>owner = models.ForeignKey('auth.User', related_name='movies')</code> 其中 <code>related_name</code> 设置了可以通过 User.movies 来逆向访问到 movies 表。所以在 <code>ModelSerializer</code> 类中我们需要在 fields 中添加一个 <code>movies</code> 来实现逆向访问。同理 <code>DirectorSerializer</code> 类中也进行相应修改。</p>

<p>接着，我们还需要在 <code>views.py</code> 中添加相应的视图。</p>

<p>为 User 添加只读 API ，使用 <code>ListAPIView</code> 和 <code>RetrieveAPIView</code></p>

<p>为 Director 添加读写 API ，使用 <code>ListCreateAPIView</code> 和 <code>RetrieveUpdateDestroyAPIView</code></p>

<pre><code class="python">class UserList(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer

class UserDetail(generics.RetrieveAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer

class DirectorList(generics.ListCreateAPIView):
    queryset = celebrity.objects.all()
    serializer_class = DirectorSerializer

class DirectorDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = celebrity.objects.all()
    serializer_class = DirectorSerializer
</code></pre>

<p>最后，修改 <code>urls.py</code> 把视图关联起来，在 <code>urlpatterns</code> 中加入以下4个 patterns:</p>

<pre><code class="python">urlpatterns = [
    url(r'^users/$', views.UserList.as_view()),
    url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', views.UserDetail.as_view()),
    url(r'^directors/$', views.DirectorList.as_view()),
    url(r'^directors/(?P&lt;pk&gt;[0-9]+)/$', views.DirectorDetail.as_view()),
]
</code></pre>

<h3>把 Movies 和 Director 、 User 关联起来</h3>

<p>现在，如果我们新建一部 movie ，那它和 director 还有 user 是没有关联的，因为 director 和 user 信息是通过 request 接收到的，而不是通过序列器接收的，这意味着，数据库中收到 director 和 user 信息是没有(和 movies 存在)外键关系的。</p>

<p>而要让他们发生关系 ，我们的做法是在视图中重写 .perform_create() 方法。</p>

<p>.perform_create() 方法允许我们处理 request 或 requested URL 中的任何信息。</p>

<p>在 <code>MoviesList</code> 和 <code>MoviesDetail</code> 中添加以下代码:</p>

<pre><code class="python">def perform_create(self, serializer):
    serializer.save(owner=self.request.user, director=self.request.celebrity)
</code></pre>

<p>这样 <code>create()</code> 方法就能够在接收到 request.data 时将其传回给序列器里的 owner 和 director 了。</p>

<h3>更新序列器</h3>

<p>在视图中重写了 <code>.perform_create()</code> 方法后还需要更新下序列器才能实现他们之间的关联，在 <code>serializer.py</code> 中的 <code>MoviesSerializer</code> 类添加以下代码:</p>

<pre><code class="python">owner = serializers.ReadOnlyField(source='owner.username')
director = serializers.CharField(source='celebrity.name')
</code></pre>

<p>接着在 <code>class Meta</code> 的 fields 中加入 owner 和 director :</p>

<pre><code class="python">class Meta:
    model = Movies
    fields = ('id', 'title', 'director', 'year', 'country', 'type', 'rating', 'owner')
</code></pre>

<p>source 关键字负责控制在 fields 中展现的数据的源，它可以指向这个序列器实例的任意一个属性。</p>

<p>对 owner 属性，我们用的是 <code>ReadOnlyField</code> 在确保它始终是只读的，我们也可以用 <code>CharField(read_only=True)</code> 来等效替代，但是我嫌它太长了，其余的 Field 还有诸如 <code>CharField</code> 、 <code>BooleanField</code> 等，你可以在 <a href="http://www.django-rest-framework.org/api-guide/fields/">「这里」</a>查到。</p>

<h3>添加权限</h3>

<p>我们希望授权的用户才能新建、更新和删除 movies，所以需要添加权限管理的功能。</p>

<p>DRF 包含了一系列的 permission 类来实现权限管理，你可以在<a href="http://www.django-rest-framework.org/api-guide/permissions/">「这里」</a> 查到。</p>

<p>在这个栗子中，我们使用  <code>IsAuthenticatedOrReadOnly</code> 来确保授权的请求得到读写的权限，未授权的请求只有只读权限。</p>

<p>首先，在 <code>views.py</code> 中 import 以下模块:</p>

<pre><code class="python">from rest_framework import permissions
</code></pre>

<p>接着，在 <code>MoviesList</code> 和 <code>MoviesDetail</code> 中加入以下代码:</p>

<pre><code class="python">permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
</code></pre>

<h3>添加可浏览的授权 api</h3>

<p>如果你在浏览器中访问我们的 api Web 界面，你会发现我们没法创建新的 movies 了，因为在上一步我们设置了权限管理。</p>

<p>所以我需要在浏览器中添加用户登录来实现带界面的权限管理。(之所以说带界面是因为可以在终端中直接使用 httpie 来访问 api )</p>

<p>在 <code>restapi/urls.py</code> 中加入以下代码:</p>

<pre><code class="python">urlpatterns += [
    url(r'^api-auth/', include('rest_framework.urls',
                               namespace='rest_framework')),
]
</code></pre>

<p>这样通过在浏览器中访问 Web api 界面就能在右上角发现一个登录按钮，进行登录授权了。</p>

<h3>对象级权限</h3>

<p>之前提到要使 movies 可以被任何人访问，但是只能被创建者编辑，所以需要赋予其游客访问的权限以及创建者编辑权限。</p>

<p>下面我们新建一个 <code>permissions.py</code> 来详细解决这个权限问题:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-
from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    游客访问权限及创建者编辑权限
    """

    def has_object_permission(self, request, view, obj):
        # 游客权限
        if request.method in permissions.SAFE_METHODS:
            return True

        # 编辑权限
        return obj.owner == request.user
</code></pre>

<p>修改 <code>views.py</code> 中 <code>MoviesDetail</code> 的 <code>permission_class</code> :</p>

<pre><code class="python">from douban.permissions import IsOwnerOrReadOnly

permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                      IsOwnerOrReadOnly,)
</code></pre>

<p>终于，我们完成了整个 api 授权的过程！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DRF 教程3 - 基于类的视图]]></title>
    <link href="http://thehackercat.me/blog/2016/04/01/drf-tutoriaial3/"/>
    <updated>2016-04-01T16:39:23+08:00</updated>
    <id>http://thehackercat.me/blog/2016/04/01/drf-tutoriaial3</id>
    <content type="html"><![CDATA[<h2>基于类的视图</h2>

<p>基于类的视图比先前基于函数的视图的可重用性更强，可以更多快好省地 ( <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> )地写出简洁的代码。</p>

<!--more-->


<h3>把 API 用基于类的视图的方式重写</h3>

<p>编辑 <code>douban/views.py</code> 进行如下重写</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-
from douban.models import Movies
from douban.serializer import MoviesSerializer
from django.http import Http404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status


class MoviesList(APIView):
    """
    罗列出所有的 Movies 或者 能新建一个 Movies
    """
    def get(self, request, format=None):
        movies = Movies.objects.all()
        serializer = MoviesSerializer(movies, many=True)
        return Response(serializer.data)

    def post(self, request, format=None):
        serializer = MoviesSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class MoviesDetail(APIView):
    """
    展示\更新或删除一个 Movies
    """
    def get_object(self, pk):
        try:
            return Movies.objects.get(pk=pk)
        except Movies.DoesNotExist:
            raise Http404

    def get(self, request, pk, format=None):
        movies = self.get_object(pk)
        serializer = MoviesSerializer(movies)
        return Response(serializer.data)

    def put(self, request, pk, format=None):
        movies = self.get_object(pk)
        serializer = MoviesSerializer(movies, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request, pk, format=None):
        movies = self.get_object(pk)
        movies.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
</code></pre>

<p>并更新 <code>douban/urls.py</code></p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from django.conf.urls import url
from rest_framework.urlpatterns import format_suffix_patterns
from douban import views

urlpatterns = [
    url(r'^dbmovies/$', views.MoviesList.as_view()),
    url(r'^dbmovies/(?P&lt;pk&gt;[0-9]+)/$', views.MoviesDetail.as_view()),
]

urlpatterns = format_suffix_patterns(urlpatterns)
</code></pre>

<p>重写完毕！</p>

<h3>使用 Mixins</h3>

<p>使用基于类的视图的一大好处是，我们可以使用各种 mixins</p>

<p>DRF 为我们提供了许多现成的 mixins ，方便我们像使用 model-backed API 一样构建 &ldquo;创建/获取/更新/删除&rdquo; API. 我们试着使用 Mixins 改写原先的 views</p>

<p>GenericAPIView 为我们提供了 views 核心的功能, 而 ListModelMixin 和 CreateModelMixin 为我们提供了 .list() 和 .create() 功能，我们将这些功能与 http 动作的 GET 和 POST 相绑定:</p>

<pre><code class="python">from douban.models import Movies
from douban.serializer import MoviesSerializer
from rest_framework import mixins
from rest_framework import generics

class MoviesList(mixins.ListModelMixin,
                  mixins.CreateModelMixin,
                  generics.GenericAPIView):
    queryset = Movies.objects.all()
    serializer_class = MoviesSerializer

    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)
</code></pre>

<p>同样的, 我们使用GenericAPIView, RetrieveModelMixin, UpdateModelMixin和DestroyModelMixin改写views.py:</p>

<pre><code class="python">class MoviesDetail(mixins.RetrieveModelMixin,
                    mixins.UpdateModelMixin,
                    mixins.DestroyModelMixin,
                    generics.GenericAPIView):
    queryset = Movies.objects.all()
    serializer_class = MoviesSerializer

    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
</code></pre>

<p>可看出，这三个 Mixin 分别对应 GET/PUT/DELETE 动作。</p>

<h3>使用通用类视图</h3>

<p>使用 Mixin 来重写 views 减少了代码量，但是还可以更少！</p>

<p>那就是使用「通用类视图」—「generic class based views」</p>

<p>同 Django 一样，DRF为我们提供了现成的通用类视图，接下来我们使用这些通用类视图再一次修改原有的 <code>views.py</code> :</p>

<pre><code class="python">from douban.models import Movies
from douban.serializer import MoviesSerializer
from rest_framework import generics

class MoviesList(generics.ListCreateAPIView):
    queryset = Movies.objects.all()
    serializer_class = MoviesSerializer

class MoviesDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Movies.objects.all()
    serializer_class = MoviesSerializer
</code></pre>

<p>这样，代码已经非常的精简了，不过坏处在于，你不知道他具体执行了什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DRF 教程2 - 请求与相应]]></title>
    <link href="http://thehackercat.me/blog/2016/04/01/drf-tutoriaial2/"/>
    <updated>2016-04-01T16:39:18+08:00</updated>
    <id>http://thehackercat.me/blog/2016/04/01/drf-tutoriaial2</id>
    <content type="html"><![CDATA[<h2>请求与响应</h2>

<h3>请求对象</h3>

<p>DRF 提供了一个 <code>request</code> 对象，它继承自 <code>HttpRequest</code> 并且提供了更丰富的对 request 的解析处理的方法。其中最核心的是 <code>request</code> 对象的 request.data 属性，它看起来和 Django 的 request.POST 相似，但是在处理 Web API 上更强大些。</p>

<pre><code class="python">request.POST  # Only handles form data.  Only works for 'POST' method.
request.data  # Handles arbitrary data.  Works for 'POST', 'PUT' and 'PATCH' methods.
</code></pre>

<p>request.data 相比于 request.POST 能够处理 api 中的 「POST」、「PUT」、「PATCH」等请求。</p>

<!--more-->


<h3>返回对象</h3>

<p>DRF 也提供了一个 <code>response</code> 对象，它能把未 render 的对象(数据)通过一定方式转化为正确的数据格式返回给客户端。</p>

<pre><code class="python">return Response(data)  # Renders to content type as requested by the client.
</code></pre>

<h3>状态码</h3>

<p>如果单独使用 Http 状态码的话代码会很难度，比如像我这种万年记不住几个很奇怪的状态码的人，在看到它们的时候还要 google 这就很伤！所以 DRF 提供了一个可读性更好的状态码标识，比如 <code>HTTP_400_BAD_REQUEST</code>  ，是不是一下就看出来这是 bad request 了。这些状态码都封装在了 <code>status</code> 模块里，使用它们比使用纯数字的 Http 状态码更安逸。</p>

<h3>封装的 API views</h3>

<p>DRF 提供了两个封装好的 API views</p>

<ol>
<li><code>@api_view</code>  这个装饰器用于基于函数的视图</li>
<li><code>APIView</code>  这个类用于基于类的视图</li>
</ol>


<p>这两个 views 提供了一些函数如确保在视图中接收到 <code>request</code> 实例和自动在 <code>response</code> 对象中添加 context 使其能够被 render 。</p>

<h3>开始撸代码吧</h3>

<p>紧接着<a href="">上节的教程</a>我们要在 views 中添加一些新功能</p>

<p>先把 <code>JSONResponse</code> 扔掉，这东西太难用了，我们不再需要它。</p>

<p>接着在 <code>douban/views.py</code> 中加入以下代码:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from douban.models import Movies
from douban.serializer import MoviesSerializer

@api_view(['GET', 'POST'])
def movies_list(request):
    """
    罗列出所有的 Movies 或者 能新建一个 Movies
    """
    if request.method == 'GET':
        movies = Movies.objects.all()
        serializer = MoviesSerializer(movies, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        serializer = MoviesSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

@api_view(['GET', 'PUT', 'DELETE'])
def movies_detail(request, pk):
    """
    展示\更新或删除一个 Movies
    """
    try:
        movies = Movies.objects.get(pk=pk)
    except Movies.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)

    if request.method == 'GET':
        serializer = MoviesSerializer(movies)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = MoviesSerializer(movies, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        movies.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
</code></pre>

<p>用上了 @api_view 后代码比之前更简洁了。</p>

<p>需要注意的是: 我们不再指明 request 和 response 中的内容类型。 request.DATA 即可用来处理 json 数据类型类型, 也可以处理 yaml 或其他数据类型。我们只需要在 response 中指定要返回的数据， DRF 能根据不同情况，自动在 response 中呈现正确的数据类型。</p>

<h3>在 URLs 中添加可选后缀</h3>

<p>现在我们的 response 对象不是像教程1中的对数据类型进行强制要求了。</p>

<p>并且对 url 也不是硬连接的。</p>

<p>那么就可以定制可选的 url 后缀，如:</p>

<p>通过 <a href="http://example.com/api/items/4/.json">http://example.com/api/items/4/.json</a> 来访问 Web API。</p>

<p>我们所需做的就是在 views 中添加 <code>format</code> 关键字:</p>

<pre><code class="python">def movies_list(request, format=None):
</code></pre>

<p>还有</p>

<pre><code class="python">def movies_detail(request, pk, format=None):
</code></pre>

<p>然后在 <code>douban/urls.py</code> 中加入 <code>format_suffix_patterns</code> :</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from django.conf.urls import url
from rest_framework.urlpatterns import format_suffix_patterns
from douban import views

urlpatterns = [
    url(r'^dbmovies/$', views.movies_list),
    url(r'^dbmovies/(?P&lt;pk&gt;[0-9]+)/$', views.movies_detail),
]

urlpatterns = format_suffix_patterns(urlpatterns)
</code></pre>

<p>不过，一般情况下，我们耶不会用到那么奇葩的 url 访问方式，以上的例子只是说明了用奇葩的 url 方式也是可以访问的 ：D</p>

<h3>再测试下我们的 API</h3>

<p>在终端中输入</p>

<pre><code class="bash">$ python manage.py runserver
</code></pre>

<p>接着来浏览器中访问 <code>http://127.0.0.1/dbmovies/</code></p>

<p><img src="http://7xse6j.com1.z0.glb.clouddn.com/apitest2.png" alt="apitest2" /></p>

<p>如果出现如图所示的 api 则说明 Web api 返回成功。</p>

<p>然后我们可以在这个页面中 POST 一个新的 Movies :</p>

<p>在表单中选择 Media type 为 json 格式并输入</p>

<pre><code class="json">{
    "id": 3,
    "title": "Carol",
    "year": "2015",
    "country": "US",
    "type": "Romance",
    "rating": "8.3"
}
</code></pre>

<p><img src="http://7xse6j.com1.z0.glb.clouddn.com/apitest3.png" alt="apipost" /></p>

<p>如果返回如下图所示，则说明 POST 成功！</p>

<p><img src="http://7xse6j.com1.z0.glb.clouddn.com/apitest4.png" alt="postsuccess" /></p>

<p>你或许会注意到，每个访问这个页面的人都能 POST 一个新的 Movies ，这是不合理的，所以需要赋予权限，这个我们日后再说。</p>

<h3>可浏览性</h3>

<p>Because the API chooses the content type of the response based on the client request, it will, by default, return an HTML-formatted representation of the resource when that resource is requested by a web browser. This allows for the API to return a fully web-browsable HTML representation.</p>

<p>Having a web-browsable API is a huge usability win, and makes developing and using your API much easier. It also dramatically lowers the barrier-to-entry for other developers wanting to inspect and work with your API.</p>

<p>See the <a href="http://www.django-rest-framework.org/topics/browsable-api/">browsable api</a> topic for more information about the browsable API feature and how to customize it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DRF 教程1 - 序列化]]></title>
    <link href="http://thehackercat.me/blog/2016/04/01/drf-tutorial1/"/>
    <updated>2016-04-01T14:27:27+08:00</updated>
    <id>http://thehackercat.me/blog/2016/04/01/drf-tutorial1</id>
    <content type="html"><![CDATA[<h2>序列化</h2>

<h3>环境搭建</h3>

<p>首先我们先新建一个 <code>restapi</code>  项目并安装上 django-rest-framework (DRF) 环境</p>

<pre><code class="bash">$ pip install djangorestframework
$ python manage.py startnewproject restapi
$ cd restapi
$ python manage.py startnewapp douban
</code></pre>

<p>接着，我们需要在 <code>setting.py</code> 里的加入如下代码:</p>

<pre><code class="python">INSTALLED_APPS = (
    ...
    'rest_framework',
    'douban',
)
</code></pre>

<!--more-->


<h3>建立模型</h3>

<p>由于我炒鸡喜欢看电影，所以仿着  <code>douban-API</code> 来做个简易的豆瓣电影的 rest-api 。</p>

<p>所以我们就用这个「仿豆瓣电影 api 」来作为栗子开始教程吧！</p>

<p>编辑 <code>douban/models.py</code> 文件并加入以下代码:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from django.db import models

# 举个栗子
COUNTRY_CHOICES = (
    ('US', 'US'),
    ('Asia', 'Asia'),
    ('CN', 'CN'),
    ('TW', 'TW'),
)
TYPE_CHOICES = (
    ('Drama', 'Drama'),
    ('Thriller', 'Thriller'),
    ('Sci-Fi', 'Sci-Fi'),
    ('Romance', 'Romance' ),
    ('Comedy', 'Comedy')
)
GENDER_CHOICES = (
    ('male', 'male'),
    ('female', 'female')
)

class movies(models.Model):
    title = models.CharField(max_length=100, blank=True, default='')
    year = models.CharField(max_length=20)
    # 在 director 关联了 movies 类 和 celecrity 类, 在第4章会用到 celebrity 类
    # director = models.ForeignKey('celebrity', related_name='movies')
    country = models.CharField(choices=COUNTRY_CHOICES, default='US', max_length=20)
    type = models.CharField(choices=TYPE_CHOICES, default='Romance', max_length=20)
    rating = models.DecimalField(max_digits=3, decimal_places=1)
    created = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('created',)

# class celebrity(models.Model):
#     name = models.CharField(max_length=100, blank=True, default='')
#     age = models.IntegerField()
#     gender = models.CharField(choices=GENDER_CHOICES, default='男', max_length=20)
</code></pre>

<p>接着在终端中运行:</p>

<pre><code class="bash">$ python manage.py makemigrations douban
$ python manage.py migrate
$ python manage.py syncdb
</code></pre>

<p>来创建一个新的 migrations 并在数据库中生成表。</p>

<h3>创建序列化类</h3>

<p>在开始构建 Web API 时，我们首先要做的就是提供对 <code>movies</code> 实例的序列化和反序列化(即对序列化后的实例进行「解码」)，这样才能生成可供浏览的 <code>json</code> 格式的 api 。我们可以通过声明「序列器」(一个和 Django 表单十分类似的玩意儿)来做到这一点。</p>

<p>在 <code>restapi</code> 目录中创建一个 <code>serializer.py</code> 文件，加入以下代码:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from rest_framework import serializers
from douban.models import movies, COUNTRY_CHOICES, TYPE_CHOICES

class MoviesSerializer(serializers.Serializer):
    pk = serializers.IntegerField(read_only=True)
    title = serializers.CharField(required=False, allow_blank=True, max_length=100)
    year = serializers.CharField(max_length=20)
    country = serializers.ChoiceField(choices=COUNTRY_CHOICES, default='US')
    type = serializers.ChoiceField(choices=TYPE_CHOICES, default='Romance')
    rating = serializers.DecimalField(max_digits=3, decimal_places=1)

    def create(self, validated_data):
        """
        根据接收到的 validated_data 创建一个 movies 实例
        """
        return movies.objects.create(**validated_data)

    def update(self, instance, validated_data):
        """
        根据接收到的 validated_data 更新并返回一个 movies 实例
        """
        instance.title = validated_data.get('title', instance.title)
        instance.year = validated_data.get('year', instance.year)
        instance.country = validated_data.get('country', instance.country)
        instance.type = validated_data.get('type', instance.type)
        instance.rating = validated_data.get('rating', instance.rating)
        instance.save()
        return instance
</code></pre>

<p>序列器的第一个部分定义了要进行序列化/反序列化的字段。</p>

<p>create() 和 update() 方法定义了符合规范的 movies 实例的创建和更新的方法。</p>

<p>序列器非常类似于 Django <code>Form</code> 表单，它包含了几种对字段常见的验证标识符，如 <code>required</code> 、 <code>max_length</code> 、 <code>default</code> 等。这些标识符实现的功能类似于 Django 表单，就不详细解释了。</p>

<p>所以序列器实现了以下两个功能:</p>

<ul>
<li>选择相应的模型</li>
<li>选择要展现的字段(验证后的)</li>
</ul>


<p>我们也可以通过使用 <code>ModelSerializer</code> 多快好省地的构建序列器，这个我们日后再说。</p>

<h3>开始使用序列器</h3>

<p>在开始项目之前，我们先熟悉下序列器，在终端中启动 Django shell :</p>

<pre><code class="bash">$ python manage.py shell
</code></pre>

<p>输入以下代码来创建2个 Movies 实例</p>

<p>「荒野猎人」和「蝙蝠侠爱上超人」</p>

<pre><code class="python">from douban.models import Movies
from douban.serializer import MoviesSerializer
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser

movies = Movies(title='The Revenant', year='2015', country='US', type='Drama', rating=7.9)
movies.save()

movies = Movies(title='Batman v Superman: Dawn of Justice',  year='2016', country='US', type='Romance', rating=6.7)
movies.save()
</code></pre>

<p>然后将其中一个实例序列化</p>

<pre><code class="python">serializer = MoviesSerializer(movies)
serializer.data

#{'rating': u'7.9', 'title': u'The Revenant', 'country': 'US', 'year': u'2015', 'pk': None, 'type': 'Drama'}
</code></pre>

<p>接着我们将以上数据转换为 JSON 格式，实现序列化</p>

<pre><code class="python">content = JSONRenderer().render(serializer.data)
content

#{"pk":null,"title":"The Revenant","year":"2015","country":"US","type":"Drama","rating":"7.9"}'
</code></pre>

<p>反序列化也类似，通过解析 Python 数据流并将数据流"引入"实例中即可</p>

<pre><code class="python">from django.utils.six import BytesIO

stream = BytesIO(content)
data = JSONParser().parse(stream)
serializer = MoviesSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
#OrderedDict([(u'title', u'The Revenant'), (u'year', u'2015'), (u'country', 'US'), (u'type', 'Drama'), (u'rating', Decimal('7.9'))])
</code></pre>

<p>可见, serializer和django form 有多么相似, 当我们写view时, 这一相似性会更加明显.</p>

<p>当我们输入参数many=True时, serializer还能序列化queryset:</p>

<pre><code class="python">serializer = MoviesSerializer(Movies.objects.all(), many=True)
serializer.data
[OrderedDict([('pk', 1), ('title', u'Batman v Superman: Dawn of Justice'), ('year', u'2016'), ('country', 'US'), ('type', 'Romance'), ('rating', u'6.7')]), OrderedDict([('pk', 2), ('title', u'The Revenant'), ('year', u'2015'), ('country', 'US'), ('type', 'Drama'), ('rating', u'7.9')])]
</code></pre>

<h3>使用更高级的 ModelSerializers</h3>

<p>接着如果你按照官网的教程走下去，你会发现上面的 <code>serializer.py</code> 是个代码冗杂的序列器，这不符合 Python 的风格。</p>

<p>所以我们要做的就是简化代码。</p>

<p>DRF 提供了更为简便的 <code>ModelSerializer</code> 类可以解决这个问题。</p>

<p>所以我们修改之前的 <code>serializer.py</code> :</p>

<pre><code class="python">class MoviesSerializer(serializers.ModelSerializer):
    class Meta:
        model = Movies
        fields = ('id', 'title', 'year', 'country', 'type', 'rating')
</code></pre>

<p>这种模式的序列器可以很方便地检查 fields 中的每个字段</p>

<p>然后在终端中打开 Django shell</p>

<pre><code class="bash">$ python manage.py shell
</code></pre>

<p>输入以下代码</p>

<pre><code class="python">from douban.serializer import MoviesSerializer
serializer = MoviesSerializer()
print(repr(serializer))

#MoviesSerializer():
    id = IntegerField(label='ID', read_only=True)
    title = CharField(allow_blank=True, max_length=100, required=False)
    year = CharField(max_length=20)
    country = ChoiceField(choices=(('US', 'US'), ('Asia', 'Asia'), ('CN', 'CN'), ('TW', 'TW')), required=False)
    type = ChoiceField(choices=(('Drama', 'Drama'), ('Thriller', 'Thriller'), ('Sci-Fi', 'Sci-Fi'), ('Romance', 'Romance'), ('Comedy', 'Comedy')), required=False)
    rating = DecimalField(decimal_places=1, max_digits=3)
</code></pre>

<p>注: <code>ModelSerializer</code> 类仅仅是创建 <code>serializer</code> 类的一个快捷方法，它除了实现以下两种方法外并没有其余的功能:</p>

<ul>
<li>声明需要展现的字段</li>
<li>定义  <code>create()</code> 和 <code>update()</code> 方法</li>
</ul>


<h3>使用 Django views 编写序列器视图</h3>

<p>为了更好理解序列器，我们不使用 DRF 的其他特性，仅仅用 Django views 模式来编写序列器的视图。</p>

<p>我们会创建一个 HttpResponse 的子类，这样就能将数据以 json 格式返回。</p>

<p>编辑 <code>douban/views.py</code> 加入以下代码:</p>

<pre><code class="python">from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser
from douban.models import Movies
from douban.serializer import MoviesSerializer

class JSONResponse(HttpResponse):
    """
    将数据转为 JSON 格式的 HttpResponse 子类
    """
    def __init__(self, data, **kwargs):
        content = JSONRenderer().render(data)
        kwargs['content_type'] = 'application/json'
        super(JSONResponse, self).__init__(content, **kwargs)
</code></pre>

<p>讲道理的话，我们 api 的根目录应该能罗列出所有的 Movies 或者 能新建一个 Movies</p>

<p>并且还需要一个用于展示、更新和删除 Movies 的 views</p>

<p>编辑 <code>douban/views.py</code> 加入以下代码:</p>

<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-

from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser
from douban.models import Movies
from douban.serializer import MoviesSerializer

class JSONResponse(HttpResponse):
    """
    将数据转为 JSON 格式的 HttpResponse 子类
    """
    def __init__(self, data, **kwargs):
        content = JSONRenderer().render(data)
        kwargs['content_type'] = 'application/json'
        super(JSONResponse, self).__init__(content, **kwargs)

@csrf_exempt
def movies_list(request):
    """
    罗列出所有的 Movies 或者 能新建一个 Movies
    """
    if request.method == 'GET':
        movies = Movies.objects.all()
        serializer = MoviesSerializer(movies, many=True)
        return JSONResponse(serializer.data)

    elif request.method == 'POST':
        data = JSONParser().parse(request)
        serializer = MoviesSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return JSONResponse(serializer.data, status=201)
        return JSONResponse(serializer.errors, status=400)

@csrf_exempt
def movies_detail(request, pk):
    """
    展示\更新或删除一个 Movies
    """
    try:
        movies = Movies.objects.get(pk=pk)
    except Movies.DoesNotExist:
        return HttpResponse(status=404)

    if request.method == 'GET':
        serializer = MoviesSerializer(movies)
        return JSONResponse(serializer.data)

    elif request.method == 'PUT':
        data = JSONParser().parse(request)
        serializer = MoviesSerializer(snippet, data=data)
        if serializer.is_valid():
            serializer.save()
            return JSONResponse(serializer.data)
        return JSONResponse(serializer.errors, status=400)

    elif request.method == 'DELETE':
        movies.delete()
        return HttpResponse(status=204)
</code></pre>

<p>我不是很弄明白这里关掉 csrf 的意义，那不如直接就不用 csrf 不就好了？</p>

<p>不管了，先放着，以后回来看 ( 吐舌头</p>

<p>最后修改 <code>douban/url.py</code> 导入相应的视图</p>

<pre><code class="python">from django.conf.urls import url
from douban import views

urlpatterns = [
    url(r'^dbmovies/$', views.movies_list),
    url(r'^dbmovies/(?P&lt;pk&gt;[0-9]+)/$', views.movies_detail),
]
</code></pre>

<p>并在 <code>restapi/url.py</code> 中 include 一下</p>

<pre><code class="python">from django.conf.urls import url, include

urlpatterns = [
    url(r'^', include('douban.urls')),
]
</code></pre>

<p>这样 url 和 views 就绑定好了。</p>

<h3>测试 Web API</h3>

<p>在终端中输入</p>

<pre><code class="bash">$ python manage.py runserver
</code></pre>

<p>接着来浏览器中访问 <code>http://127.0.0.1/dbmovies/</code></p>

<p><img src="http://7xse6j.com1.z0.glb.clouddn.com/apitest.png" alt="apitest" /></p>

<p>如果出现如图所示的 api 则说明 Web api 返回成功。</p>

<p>(顺便安利一个 chrome 插件 — <a href="https://www.baidufe.com/fehelper">FeHelper</a> 可以自动格式化 JSON 代码)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django REST Framework 快速上手]]></title>
    <link href="http://thehackercat.me/blog/2016/03/29/django-rest-framework/"/>
    <updated>2016-03-29T15:43:36+08:00</updated>
    <id>http://thehackercat.me/blog/2016/03/29/django-rest-framework</id>
    <content type="html"><![CDATA[<h2>Django REST Framework 快速上手</h2>

<h3>背景</h3>

<p>这几天正好在研究 RESTful 的方式来写 API，然后上手 Django REST 框架。</p>

<p>Django REST Framework (以下简称 DRF )是一个轻量级的库，熟悉 Django 的话可以很容易的用它来构建 Web API。</p>

<!--more-->


<h3>安装前提</h3>

<p>Django REST Framework 安装需要以下前提:</p>

<ul>
<li>Python (2.7, 3.2, 3.3, 3.4, 3.5)</li>
<li>Django (1.7+, 1.8, 1.9)</li>
</ul>


<p>我自己的环境是:</p>

<ul>
<li>Python 2.7.10</li>
<li>Django 1.8.2

<h3>安装配置</h3>

<p>安装 DRF 需要用到 <code>pip</code> 命令</p></li>
</ul>


<pre><code>pip install djangorestframework
pip install markdown    # Markdown support for the browsable API.
pip install django-filter   # Filtering support
</code></pre>

<p>或者在 GitHub 上 clone 它
<code>
git clone git@github.com:tomchristie/django-rest-framework.git
</code></p>

<p>接着在 Django Project 根目录的 <code>setting.py</code> 文件中的 <code>INSTALLED_APPS</code> 加入 <code>'rest_framework'</code></p>

<pre><code class="Python">INSTALLED_APPS = (
    ...
    'rest_framework',
)
</code></pre>

<p>如果你要使用 DRF 的 browsable API 的话，你可能还需要添加 REST 框架的登录登出视图 ( views )，辣么需要在 <code>url.py</code> 文件中加入以下代码:</p>

<pre><code>urlpatterns = [
    ...
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))
]
</code></pre>

<p>注: 这个 URL 地址可以是任意的，但是必须 include <code>'rest_framework.urls'</code> 和 <code>namespace='rest_framework'</code> 。</p>

<h3>举个栗子</h3>

<p>现在我们来看一下一个简单的用 DRF 来构建一个模型支持较好的 API 的栗子。</p>

<p>任何一个对 REST 框架的全局设置都被放在 <code>REST_FRAMEWORK</code> 的模块内，所以你需要在 <code>settings.py</code> 文件中添加以下代码来通过 <code>REST_FRAMEWORK</code> 入口进行全局设置:</p>

<pre><code class="python">REST_FRAMEWORK = {
    # Use Django's standard `django.contrib.auth` permissions,
    # or allow read-only access for unauthenticated users.
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'
    ]
}
</code></pre>

<p>现在我们可以构建 API 了，编辑 Django 项目根目录的 <code>url.py</code> 文件:</p>

<pre><code class="python">from django.conf.urls import url, include
from django.contrib.auth.models import User
from rest_framework import routers, serializers, viewsets

# Serializers define the API representation.
class UserSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = User
        fields = ('url', 'username', 'email', 'is_staff')

# ViewSets define the view behavior.
class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer

# Routers provide an easy way of automatically determining the URL conf.
router = routers.DefaultRouter()
router.register(r'users', UserViewSet)

# Wire up our API using automatic URL routing.
# Additionally, we include login URLs for the browsable API.
urlpatterns = [
    url(r'^', include(router.urls)),
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))
]
</code></pre>

<p>解释一下，</p>

<p>每个 <code>xxxSerializer</code> 都要继承 <code>ModelSerializer</code> 来选择模型和模型字段。</p>

<p>UserSerializer 类继承了更符合 RESTful 设计的 <code>HyperlinkedModelSerializer</code> 超链接模型 Serializer 类，它和普通的 <code>ModelSerializer</code> 类有以下区别:</p>

<ul>
<li>缺省状态下不包含 pk 字段</li>
<li>具有一个 url 字段，即HyperlinkedIdentityField类型</li>
<li>用HyperlinkedRelatedField表示关系，而非PrimaryKeyRelatedField</li>
</ul>


<p>然后在 <code>class Meta</code> 中选择模型和要展现的模型元素</p>

<p><code>ViewSet</code> 用来定义 View 的行为，和 Django 的 views 类似，用来处理 API 的 read 、write、 update 等方法(而 Django views 则处理 http 的 GET 和 POST )</p>

<p>在 ViewSet 实例化之后，通过 <code>Router</code> 类，最终将 URL 和 ViewSet 方法绑定起来。</p>

<p>ok，现在你可以通过在浏览器中访问 <code>http://127.0.0.1:8000/</code> 来查看你的 &lsquo;users&rsquo; API 了。</p>
]]></content>
  </entry>
  
</feed>
